
export svgval, svglength, SVG_UNITS, namespace_attributes,
    with_svg_user_length_unit, viewport_attributes, pathd, center_mark


"""
    namespace_attributes()

Return a vector of XML namestpace declaration attributes to be applied
to the root SVG element.
"""
function namespace_attributes()
    return [
        :xmlns => SVG_NAMESPACE,
        Symbol("xmlns:shaper") => SHAPER_NAMESPACE
    ]
end

"""
    with_svg_user_length_unit(body, unit::Unitful.Units)

Establish `unit` to be the units of length measurement in any SVG code
being generated by `body`.
"""
function with_svg_user_length_unit(body, unit::Unitful.Units)
    task_local_storage(:SVG_USER_LENGTH_UNIT, unit) do
        body()
    end
end


"""
    viewport_attributes(left, top, right, bottom, include_width_and_height=true)

Return a vector of SVG attributes (expressed as Pairs) to be added to
the SVG element.
"""
function viewport_attributes(left::Unitful.Length, top::Unitful.Length,
                             right::Unitful.Length, bottom::Unitful.Length,
                             include_width_and_height=true)
    to_units = task_local_storage(:SVG_USER_LENGTH_UNIT)
    left, top, right, bottom =
        (x -> ustrip(to_units, uconvert(to_units, x))).(
            (left, top, right, bottom))
    width = right - left
    height = bottom - top
    result = [:viewBox => "$left $top $width $height" ]
    if include_width_and_height
        ### PROBLEM: Without this, we fail to specify units for our
        ### measurtements.
        push!(result,
              :width => "$width$(SVG_UNITS[to_units])",
              :height => "$height$(SVG_UNITS[to_units])")
    end
    return result
end


"""
    pathd(steps...)

`pathd` is a convenience function for generating an SVG `path` element.
Each step is an array of a path step letter, e.g. `M`, `L`, `h` and
the parameters for that step.
A string suitable for use as the `d` attribute of an SVG `path`
element is returned.
"""
function pathd(steps...)
    steps = map(svg_pathd, steps)
    d = IOBuffer()
    needspace = false
    function putd(token)
	if needspace
	    write(d, " ")
            needspace = false
	end
	if token isa Char
	    write(d, token)
            needspace = true
	elseif token isa Symbol     # deprecated case
            error("Shouldn't get here")
	    putd(string(token))
            needspace = true
	elseif token isa Quantity   # deprecated case
            error("Shouldn't get here")
	    putd(svgval(token))
            needspace = true
	elseif token isa Integer
	    @printf(d, "%d", token)
            needspace = true
	elseif token isa Real
	    @printf(d, "%3f", token)
            needspace = true
        elseif token isa Point      # deprecated case
            error("Shouldn't get here")
            putd(token.x)
            putd(token.y)
	else
	    throw(ErrorException("Unsupported pathd token $token"))
	end
    end
    for step in steps
	if step isa Union{Tuple, Vector}
	    for token in step
		putd(token)
	    end
	else
	    putd(step)
	end
    end
    String(take!(d))
end


"""
    center_mark(x::Unitful.Length, y::Unitful.Length
                tail_length=0.1u"inch")

Mark the center where a hole is to be drilled.

For Shaper Origin, this is represented as a path of two lines that
meet at an angle.  Origin is positioned so that the intersection is in
the cut window but outside the acute angle, such that plunging and
withdrawing with an angles engraving bit will center drill the hole.
"""
function center_mark(x::Unitful.Length, y::Unitful.Length,
                     tail_length=0.1u"inch")
    elt("g",
        :class => "center_mark",
        elt("path",
            :d => pathd([ "M", x - tail_length, y ],
                        [ "L", x, y ],
                        [ "L", x, y - tail_length ]),
            shaper_cut_attributes(:on_line_cut)...),
        elt("circle",
            :cx => svglength(x),
            :cy => svglength(y),
            :r => svglength(tail_length),
            shaper_cut_attributes(:guide_line)...)
        )
end

